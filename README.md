# 스프링 DB 1편 - 데이터 접근 핵심 원리

## 1. JDBC 이해
### `JDBC` 가 등장한 이유   
JDBC 표준 인터페이스(Connection, Statement, ResultSet)을 정의

>`java.sql.Connection` - 연결
>`java.sql.Statement` - SQL을 담은 내용
>`java.sql.ResultSet` - SQL요청 응답

개발자는 다른 종류의 데이터베이스로 변경하더라도 표준 인터페이스만 사용해서 개발하면 됨

표준화의 한계   
> 각각의 데이터베이스 마다 SQL, 데이터타입 등의 일부 사용법이 달라 데이터베이스 변경 시 JDBC 코드는 변경하지 않더라도
> SQL은 해당 데이터베이스에 맞도록 변경해야함.

### SQL Mapper vs ORM
- `SQL Mapper` : SQL만 작성하면 되지만 SQL을 직접 작성해야함
- `ORM` : SQL을 직접 작성하지 않고 ORM 기술이 SQL 을 대신 동적으로 만들어 실행

> 어떤 기술을 사용하더라도 내부에서는 모두 JDBC를 사용하기 때문에 해당 기술들을 깊이있게 이해하기 위해서는
> JDBC가 어떻게 동작하는지 기본 원리를 알아두어야 함

### 데이터베이스 연결
- JDBC가 제공하는 `DriverManager`가 라이브러리에 등록된 DB 드라이버들을 관리하고 커넥션을 획득하는 기능을 제공

- JDBC를 사용한 CRUD는 `MemberRepositoryV0` 코드 참조

## 2. 커넥션풀과 데이터소스 이해

### 커넥션 풀 이해
- 데이터베이스 커넥션을 매번 새로 만드는 것은 시간이 많이 소모되는 일이다.
- 커넥션을 미리 생성해두고 풀로 관리하는 것이 커넥션 풀
- 커넥션을 요청시 풀에서 이미 생성되어 있는 커넥션을 획득하고 사용을 다하면 반환함.
- 대부분 `HikariCP` 사용

### DataSource 이해
- 커넥션을 획득하는 방법을 추상화 하는 인터페이스
- `MemberRepositoryV1` 코드 참조

## 3. 트랜잭션 이해

#### 트랜잭션 ACID
- 원자성: 트랜잭션 내 작업은 하나의 작업인 것처럼 모두 성공하거나 모두 실패해야함
- 일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 함
- 격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
- 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.

    트랜잭션 격리 수준
    READ COMMIT(커밋된 읽기)

#### 데이터베이스 세션
데이터베이스 서버에 연결을 요청하고 커넥션을 맺게 되면 내부에 세션이 생성됨

#### 트랜잭션
- 트랜잭션의 시작은 `Auto commit` 해제

#### DB 락
- 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는 커밋이나 롤백 전까지 다른 세션이나 해당 데이터를 수정할 수 없게 막음
- 보통 수정의 경우 락이 필요하지만 조호의 경우에도 락 사용 가능 (select for update)

#### 트랜잭션 적용
- 서비스 계층에서 트랜잭션 시작, 종료 코드가 비즈니스 로직과 섞이게 됨


## 스프링과 문제 해결 - 트랜잭션

#### 애플리케이션 구조
`프레젠테이션 계층` - `서비스 계층` - `데이터 접근 계층` - `DB 서버`

서비스 계층 - 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성

#### 트랜잭션 추상화
- 트랜잭션 매니저
PlatformTransactionManager (스프링 제공)
  
- 트랜잭션을 유지하려면? -> 커넥션을 같이 써야함
- 트랜잭션 매니저에서 내부에서 트랜잭션 동기화 매니저를 통해 커넥션 공유

#### 반복되는 트랜잭션 코드 제거
- 트랜잭션 템플릿

#### 트랜잭션 템플릿마저 의존하지 않으려면?
- 트랜잭션 AOP 적용 (`@Transactional`)
- Datasource 와 Transaction Manager 는 스프링이 자동으로 빈 등록

## 자바 예외 이해

#### 체크 예외 , 언체크 예외
- RuntimeException 을 상속한 예외 외에는 모두 체크 예외이다
- 체크 예외는 컴파일러가 예외 누락을 체크하기 때문에 무조건 처리하거나 던지거나 해야함

- 기본 원칙은 다음 2가지를 기억하자
1. 기본적으로 언체크(런타임)예외를 사용하자
2. 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자

#### 체크 예외의 문제
1. 복구 불가능한 예외경우 딱히 처리할 방법이 없음
2. 예외를 명시적으로 처리해야하기 때문에 의존성이 생김

#### 런타임 예외
- 예외를 놓칠 수 있기 때문에 문서화가 중요함

## 스프링과 문제 해결 - 예외 처리, 반복

#### 스프링 데이터 접근 예외 계층
- DataAccessException (최상위)
- NonTransientDataAccessException (영구적 예외) 
- TransientDataAccessException (일시적 예외)

#### 서비스 계층의 순수성
- 트랜잭션 추상화 + 트랜잭션 AOP 덕분에 서비스 계층의 순수성을 최대한 유지하면서 서비스 계층에서 트랜잭션을 사용
- 스프링이 제공하는 예외 추상화와 예외 변환기 덕분에, 데이터 접근 기술이 변경되어도 서비스 계층이 특정 기술에 의존하지 않음(다만 스프링에는 의존)
- 서비스 계층이 리포지토리 인터페이스에 의존한 덕분에 향후 리포지토리가 다른 구현 기술로 변경되어도 서비스 계층을 순수하게 유지

#### JdbcTemplate
- 템플릿 콜백 패턴을 통한 리포티조리 중복 코드 제거